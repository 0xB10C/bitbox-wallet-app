// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
	"github.com/shiftdevices/godbb/coins/btc/electrum/client"
)

var (
	lockInterfaceMockClose                sync.RWMutex
	lockInterfaceMockEstimateFee          sync.RWMutex
	lockInterfaceMockHeadersSubscribe     sync.RWMutex
	lockInterfaceMockRelayFee             sync.RWMutex
	lockInterfaceMockScriptHashGetHistory sync.RWMutex
	lockInterfaceMockScriptHashSubscribe  sync.RWMutex
	lockInterfaceMockTransactionBroadcast sync.RWMutex
	lockInterfaceMockTransactionGet       sync.RWMutex
)

// InterfaceMock is a mock implementation of Interface.
//
//     func TestSomethingThatUsesInterface(t *testing.T) {
//
//         // make and configure a mocked Interface
//         mockedInterface := &InterfaceMock{
//             CloseFunc: func()  {
// 	               panic("TODO: mock out the Close method")
//             },
//             EstimateFeeFunc: func(in1 int, in2 func(btcutil.Amount) error, in3 func(error)) error {
// 	               panic("TODO: mock out the EstimateFee method")
//             },
//             HeadersSubscribeFunc: func() (*client.Header, error) {
// 	               panic("TODO: mock out the HeadersSubscribe method")
//             },
//             RelayFeeFunc: func() (btcutil.Amount, error) {
// 	               panic("TODO: mock out the RelayFee method")
//             },
//             ScriptHashGetHistoryFunc: func(in1 string, in2 func(client.TxHistory) error, in3 func(error)) error {
// 	               panic("TODO: mock out the ScriptHashGetHistory method")
//             },
//             ScriptHashSubscribeFunc: func(in1 string, in2 func(string) error, in3 func(error)) error {
// 	               panic("TODO: mock out the ScriptHashSubscribe method")
//             },
//             TransactionBroadcastFunc: func(in1 *wire.MsgTx) error {
// 	               panic("TODO: mock out the TransactionBroadcast method")
//             },
//             TransactionGetFunc: func(in1 chainhash.Hash, in2 func(*wire.MsgTx) error, in3 func(error)) error {
// 	               panic("TODO: mock out the TransactionGet method")
//             },
//         }
//
//         // TODO: use mockedInterface in code that requires Interface
//         //       and then make assertions.
//
//     }
type InterfaceMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// EstimateFeeFunc mocks the EstimateFee method.
	EstimateFeeFunc func(in1 int, in2 func(btcutil.Amount) error, in3 func(error)) error

	// HeadersSubscribeFunc mocks the HeadersSubscribe method.
	HeadersSubscribeFunc func() (*client.Header, error)

	// RelayFeeFunc mocks the RelayFee method.
	RelayFeeFunc func() (btcutil.Amount, error)

	// ScriptHashGetHistoryFunc mocks the ScriptHashGetHistory method.
	ScriptHashGetHistoryFunc func(in1 string, in2 func(client.TxHistory) error, in3 func(error)) error

	// ScriptHashSubscribeFunc mocks the ScriptHashSubscribe method.
	ScriptHashSubscribeFunc func(in1 string, in2 func(string) error, in3 func(error)) error

	// TransactionBroadcastFunc mocks the TransactionBroadcast method.
	TransactionBroadcastFunc func(in1 *wire.MsgTx) error

	// TransactionGetFunc mocks the TransactionGet method.
	TransactionGetFunc func(in1 chainhash.Hash, in2 func(*wire.MsgTx) error, in3 func(error)) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// EstimateFee holds details about calls to the EstimateFee method.
		EstimateFee []struct {
			// In1 is the in1 argument value.
			In1 int
			// In2 is the in2 argument value.
			In2 func(btcutil.Amount) error
			// In3 is the in3 argument value.
			In3 func(error)
		}
		// HeadersSubscribe holds details about calls to the HeadersSubscribe method.
		HeadersSubscribe []struct {
		}
		// RelayFee holds details about calls to the RelayFee method.
		RelayFee []struct {
		}
		// ScriptHashGetHistory holds details about calls to the ScriptHashGetHistory method.
		ScriptHashGetHistory []struct {
			// In1 is the in1 argument value.
			In1 string
			// In2 is the in2 argument value.
			In2 func(client.TxHistory) error
			// In3 is the in3 argument value.
			In3 func(error)
		}
		// ScriptHashSubscribe holds details about calls to the ScriptHashSubscribe method.
		ScriptHashSubscribe []struct {
			// In1 is the in1 argument value.
			In1 string
			// In2 is the in2 argument value.
			In2 func(string) error
			// In3 is the in3 argument value.
			In3 func(error)
		}
		// TransactionBroadcast holds details about calls to the TransactionBroadcast method.
		TransactionBroadcast []struct {
			// In1 is the in1 argument value.
			In1 *wire.MsgTx
		}
		// TransactionGet holds details about calls to the TransactionGet method.
		TransactionGet []struct {
			// In1 is the in1 argument value.
			In1 chainhash.Hash
			// In2 is the in2 argument value.
			In2 func(*wire.MsgTx) error
			// In3 is the in3 argument value.
			In3 func(error)
		}
	}
}

// Close calls CloseFunc.
func (mock *InterfaceMock) Close() {
	if mock.CloseFunc == nil {
		panic("moq: InterfaceMock.CloseFunc is nil but Interface.Close was just called")
	}
	callInfo := struct {
	}{}
	lockInterfaceMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockInterfaceMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedInterface.CloseCalls())
func (mock *InterfaceMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockInterfaceMockClose.RLock()
	calls = mock.calls.Close
	lockInterfaceMockClose.RUnlock()
	return calls
}

// EstimateFee calls EstimateFeeFunc.
func (mock *InterfaceMock) EstimateFee(in1 int, in2 func(btcutil.Amount) error, in3 func(error)) error {
	if mock.EstimateFeeFunc == nil {
		panic("moq: InterfaceMock.EstimateFeeFunc is nil but Interface.EstimateFee was just called")
	}
	callInfo := struct {
		In1 int
		In2 func(btcutil.Amount) error
		In3 func(error)
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockInterfaceMockEstimateFee.Lock()
	mock.calls.EstimateFee = append(mock.calls.EstimateFee, callInfo)
	lockInterfaceMockEstimateFee.Unlock()
	return mock.EstimateFeeFunc(in1, in2, in3)
}

// EstimateFeeCalls gets all the calls that were made to EstimateFee.
// Check the length with:
//     len(mockedInterface.EstimateFeeCalls())
func (mock *InterfaceMock) EstimateFeeCalls() []struct {
	In1 int
	In2 func(btcutil.Amount) error
	In3 func(error)
} {
	var calls []struct {
		In1 int
		In2 func(btcutil.Amount) error
		In3 func(error)
	}
	lockInterfaceMockEstimateFee.RLock()
	calls = mock.calls.EstimateFee
	lockInterfaceMockEstimateFee.RUnlock()
	return calls
}

// HeadersSubscribe calls HeadersSubscribeFunc.
func (mock *InterfaceMock) HeadersSubscribe() (*client.Header, error) {
	if mock.HeadersSubscribeFunc == nil {
		panic("moq: InterfaceMock.HeadersSubscribeFunc is nil but Interface.HeadersSubscribe was just called")
	}
	callInfo := struct {
	}{}
	lockInterfaceMockHeadersSubscribe.Lock()
	mock.calls.HeadersSubscribe = append(mock.calls.HeadersSubscribe, callInfo)
	lockInterfaceMockHeadersSubscribe.Unlock()
	return mock.HeadersSubscribeFunc()
}

// HeadersSubscribeCalls gets all the calls that were made to HeadersSubscribe.
// Check the length with:
//     len(mockedInterface.HeadersSubscribeCalls())
func (mock *InterfaceMock) HeadersSubscribeCalls() []struct {
} {
	var calls []struct {
	}
	lockInterfaceMockHeadersSubscribe.RLock()
	calls = mock.calls.HeadersSubscribe
	lockInterfaceMockHeadersSubscribe.RUnlock()
	return calls
}

// RelayFee calls RelayFeeFunc.
func (mock *InterfaceMock) RelayFee() (btcutil.Amount, error) {
	if mock.RelayFeeFunc == nil {
		panic("moq: InterfaceMock.RelayFeeFunc is nil but Interface.RelayFee was just called")
	}
	callInfo := struct {
	}{}
	lockInterfaceMockRelayFee.Lock()
	mock.calls.RelayFee = append(mock.calls.RelayFee, callInfo)
	lockInterfaceMockRelayFee.Unlock()
	return mock.RelayFeeFunc()
}

// RelayFeeCalls gets all the calls that were made to RelayFee.
// Check the length with:
//     len(mockedInterface.RelayFeeCalls())
func (mock *InterfaceMock) RelayFeeCalls() []struct {
} {
	var calls []struct {
	}
	lockInterfaceMockRelayFee.RLock()
	calls = mock.calls.RelayFee
	lockInterfaceMockRelayFee.RUnlock()
	return calls
}

// ScriptHashGetHistory calls ScriptHashGetHistoryFunc.
func (mock *InterfaceMock) ScriptHashGetHistory(in1 string, in2 func(client.TxHistory) error, in3 func(error)) error {
	if mock.ScriptHashGetHistoryFunc == nil {
		panic("moq: InterfaceMock.ScriptHashGetHistoryFunc is nil but Interface.ScriptHashGetHistory was just called")
	}
	callInfo := struct {
		In1 string
		In2 func(client.TxHistory) error
		In3 func(error)
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockInterfaceMockScriptHashGetHistory.Lock()
	mock.calls.ScriptHashGetHistory = append(mock.calls.ScriptHashGetHistory, callInfo)
	lockInterfaceMockScriptHashGetHistory.Unlock()
	return mock.ScriptHashGetHistoryFunc(in1, in2, in3)
}

// ScriptHashGetHistoryCalls gets all the calls that were made to ScriptHashGetHistory.
// Check the length with:
//     len(mockedInterface.ScriptHashGetHistoryCalls())
func (mock *InterfaceMock) ScriptHashGetHistoryCalls() []struct {
	In1 string
	In2 func(client.TxHistory) error
	In3 func(error)
} {
	var calls []struct {
		In1 string
		In2 func(client.TxHistory) error
		In3 func(error)
	}
	lockInterfaceMockScriptHashGetHistory.RLock()
	calls = mock.calls.ScriptHashGetHistory
	lockInterfaceMockScriptHashGetHistory.RUnlock()
	return calls
}

// ScriptHashSubscribe calls ScriptHashSubscribeFunc.
func (mock *InterfaceMock) ScriptHashSubscribe(in1 string, in2 func(string) error, in3 func(error)) error {
	if mock.ScriptHashSubscribeFunc == nil {
		panic("moq: InterfaceMock.ScriptHashSubscribeFunc is nil but Interface.ScriptHashSubscribe was just called")
	}
	callInfo := struct {
		In1 string
		In2 func(string) error
		In3 func(error)
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockInterfaceMockScriptHashSubscribe.Lock()
	mock.calls.ScriptHashSubscribe = append(mock.calls.ScriptHashSubscribe, callInfo)
	lockInterfaceMockScriptHashSubscribe.Unlock()
	return mock.ScriptHashSubscribeFunc(in1, in2, in3)
}

// ScriptHashSubscribeCalls gets all the calls that were made to ScriptHashSubscribe.
// Check the length with:
//     len(mockedInterface.ScriptHashSubscribeCalls())
func (mock *InterfaceMock) ScriptHashSubscribeCalls() []struct {
	In1 string
	In2 func(string) error
	In3 func(error)
} {
	var calls []struct {
		In1 string
		In2 func(string) error
		In3 func(error)
	}
	lockInterfaceMockScriptHashSubscribe.RLock()
	calls = mock.calls.ScriptHashSubscribe
	lockInterfaceMockScriptHashSubscribe.RUnlock()
	return calls
}

// TransactionBroadcast calls TransactionBroadcastFunc.
func (mock *InterfaceMock) TransactionBroadcast(in1 *wire.MsgTx) error {
	if mock.TransactionBroadcastFunc == nil {
		panic("moq: InterfaceMock.TransactionBroadcastFunc is nil but Interface.TransactionBroadcast was just called")
	}
	callInfo := struct {
		In1 *wire.MsgTx
	}{
		In1: in1,
	}
	lockInterfaceMockTransactionBroadcast.Lock()
	mock.calls.TransactionBroadcast = append(mock.calls.TransactionBroadcast, callInfo)
	lockInterfaceMockTransactionBroadcast.Unlock()
	return mock.TransactionBroadcastFunc(in1)
}

// TransactionBroadcastCalls gets all the calls that were made to TransactionBroadcast.
// Check the length with:
//     len(mockedInterface.TransactionBroadcastCalls())
func (mock *InterfaceMock) TransactionBroadcastCalls() []struct {
	In1 *wire.MsgTx
} {
	var calls []struct {
		In1 *wire.MsgTx
	}
	lockInterfaceMockTransactionBroadcast.RLock()
	calls = mock.calls.TransactionBroadcast
	lockInterfaceMockTransactionBroadcast.RUnlock()
	return calls
}

// TransactionGet calls TransactionGetFunc.
func (mock *InterfaceMock) TransactionGet(in1 chainhash.Hash, in2 func(*wire.MsgTx) error, in3 func(error)) error {
	if mock.TransactionGetFunc == nil {
		panic("moq: InterfaceMock.TransactionGetFunc is nil but Interface.TransactionGet was just called")
	}
	callInfo := struct {
		In1 chainhash.Hash
		In2 func(*wire.MsgTx) error
		In3 func(error)
	}{
		In1: in1,
		In2: in2,
		In3: in3,
	}
	lockInterfaceMockTransactionGet.Lock()
	mock.calls.TransactionGet = append(mock.calls.TransactionGet, callInfo)
	lockInterfaceMockTransactionGet.Unlock()
	return mock.TransactionGetFunc(in1, in2, in3)
}

// TransactionGetCalls gets all the calls that were made to TransactionGet.
// Check the length with:
//     len(mockedInterface.TransactionGetCalls())
func (mock *InterfaceMock) TransactionGetCalls() []struct {
	In1 chainhash.Hash
	In2 func(*wire.MsgTx) error
	In3 func(error)
} {
	var calls []struct {
		In1 chainhash.Hash
		In2 func(*wire.MsgTx) error
		In3 func(error)
	}
	lockInterfaceMockTransactionGet.RLock()
	calls = mock.calls.TransactionGet
	lockInterfaceMockTransactionGet.RUnlock()
	return calls
}
